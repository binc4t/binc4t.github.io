<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="bincat"><meta name=description content="前言 最近工作中需要用到限频的功能，限制同IP在一定时间内的访问量，又因为想做成统计周期可配置，所以令牌桶不太适用，需要用滑动窗口来实现，发现了一个专门做流量访问控制的阿里的开源项目sentinel，奈何自己太菜了，直接引用了其中的滑动窗口的实现，不过还是学习了人家的写法并记录在这里
滑动窗口的基本属性 滑动窗口有两个最基本的属性，长度以及分桶数；长度决定了这个窗口有多长，也就是统计周期；分桶数决定了这个窗口的统计颗粒度。
那么滑动窗口该怎么实现呢？
滑动窗口不断向前滚动，采用新的数据，抛弃旧的数据，就很容易让人联想到环形数组。都是不断淘汰旧的数据，每次关心的只有这个环的大小，更新的和更旧的数据都不关心。
一起看一下sentinel-golang中的滑动窗口实现吧
sentinel-golang的滑动窗口实现 定义一个桶 首先定义一个桶，最简单的桶就是一个counter，下面的MetricBucket就定义了一个桶，这里的counter是二维统计，可以将Pass, Reject, Total等维度分别统计，下面的minRT和maxConcurrency可以暂时不用关心， 可以看出一个桶本质上就是一个counter
type MetricBucket struct { // Value of statistic counter [base.MetricEventTotal]int64 minRt int64 maxConcurrency int32 } 通过面的函数可以对counter值做加法
func (mb *MetricBucket) addCount(event base.MetricEvent, count int64) { atomic.AddInt64(&amp;mb.counter[event], count) } 上面的桶放之四海皆可，但是如果想成为个滑动窗口用桶，只有counter是不够的，因为滑动窗口中的每一个桶还有时间的概念，BucketWrap是对桶的封装，添加了开始时间BucketStart，Value中存放的是一个*MetricBucket
type BucketWrap struct { // BucketStart represents start timestamp of this statistic bucket wrapper. BucketStart uint64 // Value represents the actual data structure of the metrics (e.g. MetricBucket). Value atomic."><meta name=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content="学习 sentinel-golang 的滑动窗口实现"><meta name=twitter:description content="前言 最近工作中需要用到限频的功能，限制同IP在一定时间内的访问量，又因为想做成统计周期可配置，所以令牌桶不太适用，需要用滑动窗口来实现，发现了一个专门做流量访问控制的阿里的开源项目sentinel，奈何自己太菜了，直接引用了其中的滑动窗口的实现，不过还是学习了人家的写法并记录在这里
滑动窗口的基本属性 滑动窗口有两个最基本的属性，长度以及分桶数；长度决定了这个窗口有多长，也就是统计周期；分桶数决定了这个窗口的统计颗粒度。
那么滑动窗口该怎么实现呢？
滑动窗口不断向前滚动，采用新的数据，抛弃旧的数据，就很容易让人联想到环形数组。都是不断淘汰旧的数据，每次关心的只有这个环的大小，更新的和更旧的数据都不关心。
一起看一下sentinel-golang中的滑动窗口实现吧
sentinel-golang的滑动窗口实现 定义一个桶 首先定义一个桶，最简单的桶就是一个counter，下面的MetricBucket就定义了一个桶，这里的counter是二维统计，可以将Pass, Reject, Total等维度分别统计，下面的minRT和maxConcurrency可以暂时不用关心， 可以看出一个桶本质上就是一个counter
type MetricBucket struct { // Value of statistic counter [base.MetricEventTotal]int64 minRt int64 maxConcurrency int32 } 通过面的函数可以对counter值做加法
func (mb *MetricBucket) addCount(event base.MetricEvent, count int64) { atomic.AddInt64(&amp;mb.counter[event], count) } 上面的桶放之四海皆可，但是如果想成为个滑动窗口用桶，只有counter是不够的，因为滑动窗口中的每一个桶还有时间的概念，BucketWrap是对桶的封装，添加了开始时间BucketStart，Value中存放的是一个*MetricBucket
type BucketWrap struct { // BucketStart represents start timestamp of this statistic bucket wrapper. BucketStart uint64 // Value represents the actual data structure of the metrics (e.g. MetricBucket). Value atomic."><meta property="og:title" content="学习 sentinel-golang 的滑动窗口实现"><meta property="og:description" content="前言 最近工作中需要用到限频的功能，限制同IP在一定时间内的访问量，又因为想做成统计周期可配置，所以令牌桶不太适用，需要用滑动窗口来实现，发现了一个专门做流量访问控制的阿里的开源项目sentinel，奈何自己太菜了，直接引用了其中的滑动窗口的实现，不过还是学习了人家的写法并记录在这里
滑动窗口的基本属性 滑动窗口有两个最基本的属性，长度以及分桶数；长度决定了这个窗口有多长，也就是统计周期；分桶数决定了这个窗口的统计颗粒度。
那么滑动窗口该怎么实现呢？
滑动窗口不断向前滚动，采用新的数据，抛弃旧的数据，就很容易让人联想到环形数组。都是不断淘汰旧的数据，每次关心的只有这个环的大小，更新的和更旧的数据都不关心。
一起看一下sentinel-golang中的滑动窗口实现吧
sentinel-golang的滑动窗口实现 定义一个桶 首先定义一个桶，最简单的桶就是一个counter，下面的MetricBucket就定义了一个桶，这里的counter是二维统计，可以将Pass, Reject, Total等维度分别统计，下面的minRT和maxConcurrency可以暂时不用关心， 可以看出一个桶本质上就是一个counter
type MetricBucket struct { // Value of statistic counter [base.MetricEventTotal]int64 minRt int64 maxConcurrency int32 } 通过面的函数可以对counter值做加法
func (mb *MetricBucket) addCount(event base.MetricEvent, count int64) { atomic.AddInt64(&amp;mb.counter[event], count) } 上面的桶放之四海皆可，但是如果想成为个滑动窗口用桶，只有counter是不够的，因为滑动窗口中的每一个桶还有时间的概念，BucketWrap是对桶的封装，添加了开始时间BucketStart，Value中存放的是一个*MetricBucket
type BucketWrap struct { // BucketStart represents start timestamp of this statistic bucket wrapper. BucketStart uint64 // Value represents the actual data structure of the metrics (e.g. MetricBucket). Value atomic."><meta property="og:type" content="article"><meta property="og:url" content="https://binc4t.github.io/posts/sentinel-golang_slidingwindow/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-09-03T10:06:39+08:00"><meta property="article:modified_time" content="2023-09-03T10:06:39+08:00"><title>学习 sentinel-golang 的滑动窗口实现 · where dream begins!
</title><link rel=canonical href=https://binc4t.github.io/posts/sentinel-golang_slidingwindow/><link rel=preload href="/fonts/forkawesome-webfont.woff2?v=1.2.0" as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.d9fddbffe6f27e69985dc5fe0471cdb0e57fbf4775714bc3d847accb08f4a1f6.css integrity="sha256-2f3b/+byfmmYXcX+BHHNsOV/v0d1cUvD2Eesywj0ofY=" crossorigin=anonymous media=screen><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><meta name=generator content="Hugo 0.122.0"></head><body class="preload-transitions colorscheme-light"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=/>where dream begins!
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/posts/>Blog</a></li><li class=navigation-item><a class=navigation-link href=/reading>Reading</a></li><li class=navigation-item><a class=navigation-link href=/about>About</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://binc4t.github.io/posts/sentinel-golang_slidingwindow/>学习 sentinel-golang 的滑动窗口实现</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa fa-calendar" aria-hidden=true></i>
<time datetime=2023-09-03T10:06:39+08:00>September 3, 2023
</time></span><span class=reading-time><i class="fa fa-clock-o" aria-hidden=true></i>
6-minute read</span></div></div></header><div><h2 id=前言>前言
<a class=heading-link href=#%e5%89%8d%e8%a8%80><i class="fa fa-link" aria-hidden=true></i></a></h2><p>最近工作中需要用到限频的功能，限制同IP在一定时间内的访问量，又因为想做成统计周期可配置，所以令牌桶不太适用，需要用滑动窗口来实现，发现了一个专门做流量访问控制的阿里的开源项目<a href=link:https://github.com/alibaba/sentinel-golang><strong>sentinel</strong></a>，奈何自己太菜了，直接引用了其中的滑动窗口的实现，不过还是学习了人家的写法并记录在这里</p><h2 id=滑动窗口的基本属性>滑动窗口的基本属性
<a class=heading-link href=#%e6%bb%91%e5%8a%a8%e7%aa%97%e5%8f%a3%e7%9a%84%e5%9f%ba%e6%9c%ac%e5%b1%9e%e6%80%a7><i class="fa fa-link" aria-hidden=true></i></a></h2><p>滑动窗口有两个最基本的属性，长度以及分桶数；长度决定了这个窗口有多长，也就是统计周期；分桶数决定了这个窗口的统计颗粒度。</p><p>那么滑动窗口该怎么实现呢？</p><p>滑动窗口不断向前滚动，采用新的数据，抛弃旧的数据，就很容易让人联想到环形数组。都是不断淘汰旧的数据，每次关心的只有这个环的大小，更新的和更旧的数据都不关心。</p><p>一起看一下sentinel-golang中的滑动窗口实现吧</p><h2 id=sentinel-golang的滑动窗口实现>sentinel-golang的滑动窗口实现
<a class=heading-link href=#sentinel-golang%e7%9a%84%e6%bb%91%e5%8a%a8%e7%aa%97%e5%8f%a3%e5%ae%9e%e7%8e%b0><i class="fa fa-link" aria-hidden=true></i></a></h2><h3 id=定义一个桶>定义一个桶
<a class=heading-link href=#%e5%ae%9a%e4%b9%89%e4%b8%80%e4%b8%aa%e6%a1%b6><i class="fa fa-link" aria-hidden=true></i></a></h3><p>首先定义一个桶，最简单的桶就是一个counter，下面的<code>MetricBucket</code>就定义了一个桶，这里的counter是二维统计，可以将Pass, Reject, Total等维度分别统计，下面的<code>minRT</code>和<code>maxConcurrency</code>可以暂时不用关心， 可以看出一个桶本质上就是一个counter</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=display:flex><span><span style=color:#000;font-weight:700>type</span> MetricBucket <span style=color:#000;font-weight:700>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#998;font-style:italic>// Value of statistic
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	counter        [base.MetricEventTotal]<span style=color:#458;font-weight:700>int64</span>
</span></span><span style=display:flex><span>	minRt          <span style=color:#458;font-weight:700>int64</span>
</span></span><span style=display:flex><span>	maxConcurrency <span style=color:#458;font-weight:700>int32</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>通过面的函数可以对counter值做加法</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> (mb <span style=color:#000;font-weight:700>*</span>MetricBucket) <span style=color:#900;font-weight:700>addCount</span>(event base.MetricEvent, count <span style=color:#458;font-weight:700>int64</span>) {
</span></span><span style=display:flex><span>	atomic.<span style=color:#900;font-weight:700>AddInt64</span>(<span style=color:#000;font-weight:700>&amp;</span>mb.counter[event], count)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上面的桶放之四海皆可，但是如果想成为个滑动窗口用桶，只有counter是不够的，因为滑动窗口中的每一个桶还有时间的概念，BucketWrap是对桶的封装，添加了开始时间<code>BucketStart</code>，Value中存放的是一个<code>*MetricBucket</code></p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>type BucketWrap struct {
</span></span><span style=display:flex><span>	// BucketStart represents start timestamp of this statistic bucket wrapper.
</span></span><span style=display:flex><span>	BucketStart uint64
</span></span><span style=display:flex><span>	// Value represents the actual data structure of the metrics (e.g. MetricBucket).
</span></span><span style=display:flex><span>	Value atomic.Value
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=定义桶数组>定义桶数组
<a class=heading-link href=#%e5%ae%9a%e4%b9%89%e6%a1%b6%e6%95%b0%e7%bb%84><i class="fa fa-link" aria-hidden=true></i></a></h3><p><code>AtomicBucketWrapArray</code>是一个环形数组的实现</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=display:flex><span><span style=color:#998;font-style:italic>// AtomicBucketWrapArray represents a thread-safe circular array.
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic>//
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic>// The length of the array should be provided on-create and cannot be modified.
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span><span style=color:#000;font-weight:700>type</span> AtomicBucketWrapArray <span style=color:#000;font-weight:700>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#998;font-style:italic>// The base address for real data array
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	base unsafe.Pointer
</span></span><span style=display:flex><span>	<span style=color:#998;font-style:italic>// The length of slice(array), it can not be modified.
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	length <span style=color:#458;font-weight:700>int</span>
</span></span><span style=display:flex><span>	data   []<span style=color:#000;font-weight:700>*</span>BucketWrap
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>LeapArray</code>则是在环形数组的基础上加入了滑动窗口的三个属性，桶长度、分桶数、滑动窗口总长度，使环形数组成为一个滑动窗口，这个是滑动窗口的核心结构</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=display:flex><span><span style=color:#998;font-style:italic>// LeapArray represents the fundamental implementation of a sliding window data-structure.
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic>//
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic>// Some important attributes: the sampleCount represents the number of buckets,
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic>// while intervalInMs represents the total time span of the sliding window.
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic>//
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic>// For example, assuming sampleCount=5, intervalInMs is 1000ms, so the bucketLength is 200ms.
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic>// Let&#39;s give a diagram to illustrate.
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic>// Suppose current timestamp is 1188, bucketLength is 200ms, intervalInMs is 1000ms, then
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic>// time span of current bucket is [1000, 1200). The representation of the underlying structure:
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic>//
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic>//	 B0       B1      B2     B3      B4
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic>//	 |_______|_______|_______|_______|_______|
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic>//	1000    1200    400     600     800    (1000) ms
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic>//	       ^
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic>//	    time=1188
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span><span style=color:#000;font-weight:700>type</span> LeapArray <span style=color:#000;font-weight:700>struct</span> {
</span></span><span style=display:flex><span>	bucketLengthInMs <span style=color:#458;font-weight:700>uint32</span>
</span></span><span style=display:flex><span>	<span style=color:#998;font-style:italic>// sampleCount represents the number of BucketWrap.
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	sampleCount <span style=color:#458;font-weight:700>uint32</span>
</span></span><span style=display:flex><span>	<span style=color:#998;font-style:italic>// intervalInMs represents the total time span of the sliding window (in milliseconds).
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	intervalInMs <span style=color:#458;font-weight:700>uint32</span>
</span></span><span style=display:flex><span>	<span style=color:#998;font-style:italic>// array represents the internal circular array.
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	array <span style=color:#000;font-weight:700>*</span>AtomicBucketWrapArray
</span></span><span style=display:flex><span>	<span style=color:#998;font-style:italic>// updateLock is the internal lock for update operations.
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	updateLock mutex
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=关键函数>关键函数
<a class=heading-link href=#%e5%85%b3%e9%94%ae%e5%87%bd%e6%95%b0><i class="fa fa-link" aria-hidden=true></i></a></h3><p>对于滑动窗口来说，最重要的两件事情，一个是计数器+1，一个是获得窗口内所有分桶的统计和，下面分别介绍</p><h4 id=计数器1>计数器+1
<a class=heading-link href=#%e8%ae%a1%e6%95%b0%e5%99%a81><i class="fa fa-link" aria-hidden=true></i></a></h4><p>计数器+1可以分解成下面两件事情</p><ul><li>根据当前时间找到对应的桶</li><li>对这个桶的计数器+1
下面的函数也清楚的描述了这两个步骤</li></ul><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> (bla <span style=color:#000;font-weight:700>*</span>BucketLeapArray) <span style=color:#900;font-weight:700>addCountWithTime</span>(now <span style=color:#458;font-weight:700>uint64</span>, event base.MetricEvent, count <span style=color:#458;font-weight:700>int64</span>) {
</span></span><span style=display:flex><span>	b <span style=color:#000;font-weight:700>:=</span> bla.<span style=color:#900;font-weight:700>currentBucketWithTime</span>(now) <span style=color:#998;font-style:italic>// 根据当前时间找到对应的桶
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	<span style=color:#000;font-weight:700>if</span> b <span style=color:#000;font-weight:700>==</span> <span style=color:#000;font-weight:700>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#000;font-weight:700>return</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	b.<span style=color:#900;font-weight:700>Add</span>(event, count) <span style=color:#998;font-style:italic>// 对这个桶的计数器做加法
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>}
</span></span></code></pre></div><p>根据当前时间找到对应的桶</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> (la <span style=color:#000;font-weight:700>*</span>LeapArray) <span style=color:#900;font-weight:700>currentBucketOfTime</span>(now <span style=color:#458;font-weight:700>uint64</span>, bg BucketGenerator) (<span style=color:#000;font-weight:700>*</span>BucketWrap, <span style=color:#458;font-weight:700>error</span>) {
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>if</span> now <span style=color:#000;font-weight:700>&lt;=</span> <span style=color:#099>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#000;font-weight:700>return</span> <span style=color:#000;font-weight:700>nil</span>, errors.<span style=color:#900;font-weight:700>New</span>(<span style=color:#d14>&#34;Current time is less than 0.&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	idx <span style=color:#000;font-weight:700>:=</span> la.<span style=color:#900;font-weight:700>calculateTimeIdx</span>(now)
</span></span><span style=display:flex><span>	bucketStart <span style=color:#000;font-weight:700>:=</span> <span style=color:#900;font-weight:700>calculateStartTime</span>(now, la.bucketLengthInMs)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>for</span> { <span style=color:#998;font-style:italic>//spin to get the current BucketWrap
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>		old <span style=color:#000;font-weight:700>:=</span> la.array.<span style=color:#900;font-weight:700>get</span>(idx)
</span></span><span style=display:flex><span>		<span style=color:#000;font-weight:700>if</span> old <span style=color:#000;font-weight:700>==</span> <span style=color:#000;font-weight:700>nil</span> {
</span></span><span style=display:flex><span>			<span style=color:#998;font-style:italic>// because la.array.data had initiated when new la.array
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>			<span style=color:#998;font-style:italic>// theoretically, here is not reachable
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>			newWrap <span style=color:#000;font-weight:700>:=</span> <span style=color:#000;font-weight:700>&amp;</span>BucketWrap{
</span></span><span style=display:flex><span>				BucketStart: bucketStart,
</span></span><span style=display:flex><span>				Value:       atomic.Value{},
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>			newWrap.Value.<span style=color:#900;font-weight:700>Store</span>(bg.<span style=color:#900;font-weight:700>NewEmptyBucket</span>())
</span></span><span style=display:flex><span>			<span style=color:#000;font-weight:700>if</span> la.array.<span style=color:#900;font-weight:700>compareAndSet</span>(idx, <span style=color:#000;font-weight:700>nil</span>, newWrap) {
</span></span><span style=display:flex><span>				<span style=color:#000;font-weight:700>return</span> newWrap, <span style=color:#000;font-weight:700>nil</span>
</span></span><span style=display:flex><span>			} <span style=color:#000;font-weight:700>else</span> {
</span></span><span style=display:flex><span>				runtime.<span style=color:#900;font-weight:700>Gosched</span>()
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>		} <span style=color:#000;font-weight:700>else</span> <span style=color:#000;font-weight:700>if</span> bucketStart <span style=color:#000;font-weight:700>==</span> atomic.<span style=color:#900;font-weight:700>LoadUint64</span>(<span style=color:#000;font-weight:700>&amp;</span>old.BucketStart) {
</span></span><span style=display:flex><span>			<span style=color:#000;font-weight:700>return</span> old, <span style=color:#000;font-weight:700>nil</span>
</span></span><span style=display:flex><span>		} <span style=color:#000;font-weight:700>else</span> <span style=color:#000;font-weight:700>if</span> bucketStart &gt; atomic.<span style=color:#900;font-weight:700>LoadUint64</span>(<span style=color:#000;font-weight:700>&amp;</span>old.BucketStart) {
</span></span><span style=display:flex><span>			<span style=color:#998;font-style:italic>// current time has been next cycle of LeapArray and LeapArray dont&#39;t count in last cycle.
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>			<span style=color:#998;font-style:italic>// reset BucketWrap
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>			<span style=color:#000;font-weight:700>if</span> la.updateLock.<span style=color:#900;font-weight:700>TryLock</span>() {
</span></span><span style=display:flex><span>				old = bg.<span style=color:#900;font-weight:700>ResetBucketTo</span>(old, bucketStart)
</span></span><span style=display:flex><span>				la.updateLock.<span style=color:#900;font-weight:700>Unlock</span>()
</span></span><span style=display:flex><span>				<span style=color:#000;font-weight:700>return</span> old, <span style=color:#000;font-weight:700>nil</span>
</span></span><span style=display:flex><span>			} <span style=color:#000;font-weight:700>else</span> {
</span></span><span style=display:flex><span>				runtime.<span style=color:#900;font-weight:700>Gosched</span>()
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>		} <span style=color:#000;font-weight:700>else</span> <span style=color:#000;font-weight:700>if</span> bucketStart &lt; atomic.<span style=color:#900;font-weight:700>LoadUint64</span>(<span style=color:#000;font-weight:700>&amp;</span>old.BucketStart) {
</span></span><span style=display:flex><span>			<span style=color:#000;font-weight:700>if</span> la.sampleCount <span style=color:#000;font-weight:700>==</span> <span style=color:#099>1</span> {
</span></span><span style=display:flex><span>				<span style=color:#998;font-style:italic>// if sampleCount==1 in leap array, in concurrency scenario, this case is possible
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>				<span style=color:#000;font-weight:700>return</span> old, <span style=color:#000;font-weight:700>nil</span>
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>			<span style=color:#998;font-style:italic>// TODO: reserve for some special case (e.g. when occupying &#34;future&#34; buckets).
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>			<span style=color:#000;font-weight:700>return</span> <span style=color:#000;font-weight:700>nil</span>, errors.<span style=color:#900;font-weight:700>New</span>(fmt.<span style=color:#900;font-weight:700>Sprintf</span>(<span style=color:#d14>&#34;Provided time timeMillis=%d is already behind old.BucketStart=%d.&#34;</span>, bucketStart, old.BucketStart))
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>先是通过下面两个函数确定桶在环形数组的idx，以及这个桶的起始时间应该是多少。</p><p>根据当前时间，算出对应的桶，在环形数组的那一个位置，这个是环形数组的经典的取模运算</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> (la <span style=color:#000;font-weight:700>*</span>LeapArray) <span style=color:#900;font-weight:700>calculateTimeIdx</span>(now <span style=color:#458;font-weight:700>uint64</span>) <span style=color:#458;font-weight:700>int</span> {
</span></span><span style=display:flex><span>	timeId <span style=color:#000;font-weight:700>:=</span> now <span style=color:#000;font-weight:700>/</span> <span style=color:#0086b3>uint64</span>(la.bucketLengthInMs)
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>return</span> <span style=color:#0086b3>int</span>(timeId) <span style=color:#000;font-weight:700>%</span> la.array.length
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>根据当前时间，算出对应分桶的开始时间是多少</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>calculateStartTime</span>(now <span style=color:#458;font-weight:700>uint64</span>, bucketLengthInMs <span style=color:#458;font-weight:700>uint32</span>) <span style=color:#458;font-weight:700>uint64</span> {
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>return</span> now <span style=color:#000;font-weight:700>-</span> (now <span style=color:#000;font-weight:700>%</span> <span style=color:#0086b3>uint64</span>(bucketLengthInMs))
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这里为什么要算起始时间呢？<br>因为环形数组上当前idx所在的桶，他不一定就是正确的桶，可能需要更新，比如在环形窗口最新和最旧桶的交接处，滑动窗口需要向前滑动一个桶的位置了，那么就需要淘汰最旧的桶，并将其数据清零。</p><p>接着是一个for循环</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=display:flex><span>	<span style=color:#000;font-weight:700>for</span> { <span style=color:#998;font-style:italic>//spin to get the current BucketWrap
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>		old <span style=color:#000;font-weight:700>:=</span> la.array.<span style=color:#900;font-weight:700>get</span>(idx)
</span></span><span style=display:flex><span>		<span style=color:#000;font-weight:700>if</span> old <span style=color:#000;font-weight:700>==</span> <span style=color:#000;font-weight:700>nil</span> {
</span></span><span style=display:flex><span>			<span style=color:#998;font-style:italic>// because la.array.data had initiated when new la.array
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>			<span style=color:#998;font-style:italic>// theoretically, here is not reachable
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>			newWrap <span style=color:#000;font-weight:700>:=</span> <span style=color:#000;font-weight:700>&amp;</span>BucketWrap{
</span></span><span style=display:flex><span>				BucketStart: bucketStart,
</span></span><span style=display:flex><span>				Value:       atomic.Value{},
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>			newWrap.Value.<span style=color:#900;font-weight:700>Store</span>(bg.<span style=color:#900;font-weight:700>NewEmptyBucket</span>())
</span></span><span style=display:flex><span>			<span style=color:#000;font-weight:700>if</span> la.array.<span style=color:#900;font-weight:700>compareAndSet</span>(idx, <span style=color:#000;font-weight:700>nil</span>, newWrap) {
</span></span><span style=display:flex><span>				<span style=color:#000;font-weight:700>return</span> newWrap, <span style=color:#000;font-weight:700>nil</span>
</span></span><span style=display:flex><span>			} <span style=color:#000;font-weight:700>else</span> {
</span></span><span style=display:flex><span>				runtime.<span style=color:#900;font-weight:700>Gosched</span>()
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>		} <span style=color:#000;font-weight:700>else</span> <span style=color:#000;font-weight:700>if</span> bucketStart <span style=color:#000;font-weight:700>==</span> atomic.<span style=color:#900;font-weight:700>LoadUint64</span>(<span style=color:#000;font-weight:700>&amp;</span>old.BucketStart) {
</span></span><span style=display:flex><span>			<span style=color:#000;font-weight:700>return</span> old, <span style=color:#000;font-weight:700>nil</span>
</span></span><span style=display:flex><span>		} <span style=color:#000;font-weight:700>else</span> <span style=color:#000;font-weight:700>if</span> bucketStart &gt; atomic.<span style=color:#900;font-weight:700>LoadUint64</span>(<span style=color:#000;font-weight:700>&amp;</span>old.BucketStart) {
</span></span><span style=display:flex><span>			<span style=color:#998;font-style:italic>// current time has been next cycle of LeapArray and LeapArray dont&#39;t count in last cycle.
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>			<span style=color:#998;font-style:italic>// reset BucketWrap
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>			<span style=color:#000;font-weight:700>if</span> la.updateLock.<span style=color:#900;font-weight:700>TryLock</span>() {
</span></span><span style=display:flex><span>				old = bg.<span style=color:#900;font-weight:700>ResetBucketTo</span>(old, bucketStart)
</span></span><span style=display:flex><span>				la.updateLock.<span style=color:#900;font-weight:700>Unlock</span>()
</span></span><span style=display:flex><span>				<span style=color:#000;font-weight:700>return</span> old, <span style=color:#000;font-weight:700>nil</span>
</span></span><span style=display:flex><span>			} <span style=color:#000;font-weight:700>else</span> {
</span></span><span style=display:flex><span>				runtime.<span style=color:#900;font-weight:700>Gosched</span>()
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>		} <span style=color:#000;font-weight:700>else</span> <span style=color:#000;font-weight:700>if</span> bucketStart &lt; atomic.<span style=color:#900;font-weight:700>LoadUint64</span>(<span style=color:#000;font-weight:700>&amp;</span>old.BucketStart) {
</span></span><span style=display:flex><span>			<span style=color:#000;font-weight:700>if</span> la.sampleCount <span style=color:#000;font-weight:700>==</span> <span style=color:#099>1</span> {
</span></span><span style=display:flex><span>				<span style=color:#998;font-style:italic>// if sampleCount==1 in leap array, in concurrency scenario, this case is possible
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>				<span style=color:#000;font-weight:700>return</span> old, <span style=color:#000;font-weight:700>nil</span>
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>			<span style=color:#998;font-style:italic>// TODO: reserve for some special case (e.g. when occupying &#34;future&#34; buckets).
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>			<span style=color:#000;font-weight:700>return</span> <span style=color:#000;font-weight:700>nil</span>, errors.<span style=color:#900;font-weight:700>New</span>(fmt.<span style=color:#900;font-weight:700>Sprintf</span>(<span style=color:#d14>&#34;Provided time timeMillis=%d is already behind old.BucketStart=%d.&#34;</span>, bucketStart, old.BucketStart))
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span></code></pre></div><p>在for循环中，比较真实的startTime和环形数组上桶的startTime，有三种情况</p><ul><li>如果桶的startTime小了，就说明这个桶需要更新，调用<code>ResetBucketTo</code>对桶的startTime做更新，以及Reset所有数据；</li><li>如果相等，那么直接返回这个桶；</li><li>如果桶的startTime反而大，那么只有在并发情况下，且整个窗口只有一个分桶的时候才可能出现</li></ul><p>为什么只有一个分桶的时候才可能出现startTime大于实际值的情况呢？<br>因为只有一个分桶的时候，无论怎么算idx，都是会返回idx=0，
假如starTime是t0，有前后两个时间，分别比t0稍大和稍小，并发下，比t0稍大的那个goroutine更新了这个桶，startTime变更了startTime+bucketLen，那么这时候比t0稍小的goroutine运行到这里就会到这个分枝</p><p>如果有至少两个分桶，那么上述的分别比t0稍大和稍小的两个请求一定会算到不同的桶上</p><p>注意在更新桶的时候用了这样的结构，这样可以在并发的时候，发现别的goroutine正在更新桶，那么就先让别人更新，让出线程，去调度到别的goroutine，这样自己继续for循环的时候就可以走到startTime相等的分支，直接返回即可了，也不会占用goroutine，等待锁的返回</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=display:flex><span><span style=color:#000;font-weight:700>if</span> la.updateLock.<span style=color:#900;font-weight:700>TryLock</span>() {
</span></span><span style=display:flex><span>    old = bg.<span style=color:#900;font-weight:700>ResetBucketTo</span>(old, bucketStart)
</span></span><span style=display:flex><span>    la.updateLock.<span style=color:#900;font-weight:700>Unlock</span>()
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>return</span> old, <span style=color:#000;font-weight:700>nil</span>
</span></span><span style=display:flex><span>} <span style=color:#000;font-weight:700>else</span> {
</span></span><span style=display:flex><span>    runtime.<span style=color:#900;font-weight:700>Gosched</span>()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>找到对应桶后，对桶计数器+1，本质上是这样的函数</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> (mb <span style=color:#000;font-weight:700>*</span>MetricBucket) <span style=color:#900;font-weight:700>addCount</span>(event base.MetricEvent, count <span style=color:#458;font-weight:700>int64</span>) {
</span></span><span style=display:flex><span>	atomic.<span style=color:#900;font-weight:700>AddInt64</span>(<span style=color:#000;font-weight:700>&amp;</span>mb.counter[event], count)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=获得窗口内所有分桶的统计和>获得窗口内所有分桶的统计和
<a class=heading-link href=#%e8%8e%b7%e5%be%97%e7%aa%97%e5%8f%a3%e5%86%85%e6%89%80%e6%9c%89%e5%88%86%e6%a1%b6%e7%9a%84%e7%bb%9f%e8%ae%a1%e5%92%8c><i class="fa fa-link" aria-hidden=true></i></a></h4><p>就像下面函数描述的那样，这个也分为两个步骤</p><ul><li>根据当前时间获取在有效时间范围内的所有桶</li><li>把这些桶的计数加起来</li></ul><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> (m <span style=color:#000;font-weight:700>*</span>SlidingWindowMetric) <span style=color:#900;font-weight:700>getSumWithTime</span>(now <span style=color:#458;font-weight:700>uint64</span>, event base.MetricEvent) <span style=color:#458;font-weight:700>int64</span> {
</span></span><span style=display:flex><span>	satisfiedBuckets <span style=color:#000;font-weight:700>:=</span> m.<span style=color:#900;font-weight:700>getSatisfiedBuckets</span>(now) <span style=color:#998;font-style:italic>// 根据当前时间获取在有效时间范围内的所有桶
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	<span style=color:#000;font-weight:700>return</span> m.<span style=color:#900;font-weight:700>count</span>(event, satisfiedBuckets) <span style=color:#998;font-style:italic>// 把这些桶的计数加起来
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>}
</span></span></code></pre></div><p>第一步获取在有效时间范围内的所有桶</p><ol><li>首先什么是有效时间范围</li></ol><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=display:flex><span><span style=color:#998;font-style:italic>// getBucketStartRange returns start time range of the bucket for the provided time.
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic>// The actual time span is: [start, end + in.bucketTimeLength)
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span><span style=color:#000;font-weight:700>func</span> (m <span style=color:#000;font-weight:700>*</span>SlidingWindowMetric) <span style=color:#900;font-weight:700>getBucketStartRange</span>(timeMs <span style=color:#458;font-weight:700>uint64</span>) (start, end <span style=color:#458;font-weight:700>uint64</span>) {
</span></span><span style=display:flex><span>	curBucketStartTime <span style=color:#000;font-weight:700>:=</span> <span style=color:#900;font-weight:700>calculateStartTime</span>(timeMs, m.real.<span style=color:#900;font-weight:700>BucketLengthInMs</span>())
</span></span><span style=display:flex><span>	end = curBucketStartTime
</span></span><span style=display:flex><span>	start = end <span style=color:#000;font-weight:700>-</span> <span style=color:#0086b3>uint64</span>(m.intervalInMs) <span style=color:#000;font-weight:700>+</span> <span style=color:#0086b3>uint64</span>(m.real.<span style=color:#900;font-weight:700>BucketLengthInMs</span>())
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>return</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=2><li>然后获取这个区间内的所有桶
通过下面的三层调用，把判断是否有效的方法传给下层，然后在<code>ValuesConditional</code>函数中遍历所有桶判断是否满足条件，非空、未过期且有效</li></ol><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=display:flex><span>satisfiedBuckets <span style=color:#000;font-weight:700>:=</span> m.real.<span style=color:#900;font-weight:700>ValuesConditional</span>(now, <span style=color:#000;font-weight:700>func</span>(ws <span style=color:#458;font-weight:700>uint64</span>) <span style=color:#458;font-weight:700>bool</span> {
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>return</span> ws <span style=color:#000;font-weight:700>&gt;=</span> start <span style=color:#000;font-weight:700>&amp;&amp;</span> ws <span style=color:#000;font-weight:700>&lt;=</span> end
</span></span><span style=display:flex><span>})
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> (bla <span style=color:#000;font-weight:700>*</span>BucketLeapArray) <span style=color:#900;font-weight:700>ValuesConditional</span>(now <span style=color:#458;font-weight:700>uint64</span>, predicate base.TimePredicate) []<span style=color:#000;font-weight:700>*</span>BucketWrap {
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>return</span> bla.data.<span style=color:#900;font-weight:700>ValuesConditional</span>(now, predicate)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#998;font-style:italic>// ValuesConditional returns all buckets of which the startTimestamp satisfies the given timestamp condition (predicate).
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic>// The function uses the parameter &#34;now&#34; as the target timestamp.
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span><span style=color:#000;font-weight:700>func</span> (la <span style=color:#000;font-weight:700>*</span>LeapArray) <span style=color:#900;font-weight:700>ValuesConditional</span>(now <span style=color:#458;font-weight:700>uint64</span>, predicate base.TimePredicate) []<span style=color:#000;font-weight:700>*</span>BucketWrap {
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>if</span> now <span style=color:#000;font-weight:700>&lt;=</span> <span style=color:#099>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#000;font-weight:700>return</span> <span style=color:#0086b3>make</span>([]<span style=color:#000;font-weight:700>*</span>BucketWrap, <span style=color:#099>0</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	ret <span style=color:#000;font-weight:700>:=</span> <span style=color:#0086b3>make</span>([]<span style=color:#000;font-weight:700>*</span>BucketWrap, <span style=color:#099>0</span>, la.array.length)
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>for</span> i <span style=color:#000;font-weight:700>:=</span> <span style=color:#099>0</span>; i &lt; la.array.length; i<span style=color:#000;font-weight:700>++</span> {
</span></span><span style=display:flex><span>		ww <span style=color:#000;font-weight:700>:=</span> la.array.<span style=color:#900;font-weight:700>get</span>(i)
</span></span><span style=display:flex><span>		<span style=color:#000;font-weight:700>if</span> ww <span style=color:#000;font-weight:700>==</span> <span style=color:#000;font-weight:700>nil</span> <span style=color:#000;font-weight:700>||</span> la.<span style=color:#900;font-weight:700>isBucketDeprecated</span>(now, ww) <span style=color:#000;font-weight:700>||</span> !<span style=color:#900;font-weight:700>predicate</span>(atomic.<span style=color:#900;font-weight:700>LoadUint64</span>(<span style=color:#000;font-weight:700>&amp;</span>ww.BucketStart)) {
</span></span><span style=display:flex><span>			<span style=color:#000;font-weight:700>continue</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		ret = <span style=color:#0086b3>append</span>(ret, ww)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>return</span> ret
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>其中isBucketDeprecated定义如下<span style=color:#a61717;background-color:#e3d2d2>，</span>即当前时间和桶的startTime的时间差不超过滑动窗口的长度
</span></span><span style=display:flex><span><span style=color:#998;font-style:italic>// isBucketDeprecated checks whether the BucketWrap is expired, according to given timestamp.
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span><span style=color:#000;font-weight:700>func</span> (la <span style=color:#000;font-weight:700>*</span>LeapArray) <span style=color:#900;font-weight:700>isBucketDeprecated</span>(now <span style=color:#458;font-weight:700>uint64</span>, ww <span style=color:#000;font-weight:700>*</span>BucketWrap) <span style=color:#458;font-weight:700>bool</span> {
</span></span><span style=display:flex><span>	ws <span style=color:#000;font-weight:700>:=</span> atomic.<span style=color:#900;font-weight:700>LoadUint64</span>(<span style=color:#000;font-weight:700>&amp;</span>ww.BucketStart)
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>return</span> (now <span style=color:#000;font-weight:700>-</span> ws) &gt; <span style=color:#0086b3>uint64</span>(la.intervalInMs)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>其实在这里case里predicate的条件已经能保证桶不过期了，但是这样写是为了通用吧，因为predicate可以传入任何方法</p><p>获取所有桶之后，对他们的数据相加得到结果</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> (m <span style=color:#000;font-weight:700>*</span>SlidingWindowMetric) <span style=color:#900;font-weight:700>count</span>(event base.MetricEvent, values []<span style=color:#000;font-weight:700>*</span>BucketWrap) <span style=color:#458;font-weight:700>int64</span> {
</span></span><span style=display:flex><span>	ret <span style=color:#000;font-weight:700>:=</span> <span style=color:#0086b3>int64</span>(<span style=color:#099>0</span>)
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>for</span> _, ww <span style=color:#000;font-weight:700>:=</span> <span style=color:#000;font-weight:700>range</span> values {
</span></span><span style=display:flex><span>		mb <span style=color:#000;font-weight:700>:=</span> ww.Value.<span style=color:#900;font-weight:700>Load</span>()
</span></span><span style=display:flex><span>		<span style=color:#000;font-weight:700>if</span> mb <span style=color:#000;font-weight:700>==</span> <span style=color:#000;font-weight:700>nil</span> {
</span></span><span style=display:flex><span>			logging.<span style=color:#900;font-weight:700>Error</span>(errors.<span style=color:#900;font-weight:700>New</span>(<span style=color:#d14>&#34;nil BucketWrap&#34;</span>), <span style=color:#d14>&#34;Current bucket value is nil in SlidingWindowMetric.count()&#34;</span>)
</span></span><span style=display:flex><span>			<span style=color:#000;font-weight:700>continue</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		counter, ok <span style=color:#000;font-weight:700>:=</span> mb.(<span style=color:#000;font-weight:700>*</span>MetricBucket)
</span></span><span style=display:flex><span>		<span style=color:#000;font-weight:700>if</span> !ok {
</span></span><span style=display:flex><span>			logging.<span style=color:#900;font-weight:700>Error</span>(errors.<span style=color:#900;font-weight:700>New</span>(<span style=color:#d14>&#34;type assert failed&#34;</span>), <span style=color:#d14>&#34;Fail to do type assert in SlidingWindowMetric.count()&#34;</span>, <span style=color:#d14>&#34;expectType&#34;</span>, <span style=color:#d14>&#34;*MetricBucket&#34;</span>, <span style=color:#d14>&#34;actualType&#34;</span>, reflect.<span style=color:#900;font-weight:700>TypeOf</span>(mb).<span style=color:#900;font-weight:700>Name</span>())
</span></span><span style=display:flex><span>			<span style=color:#000;font-weight:700>continue</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		ret <span style=color:#000;font-weight:700>+=</span> counter.<span style=color:#900;font-weight:700>Get</span>(event)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>return</span> ret
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=其他收获>其他收获
<a class=heading-link href=#%e5%85%b6%e4%bb%96%e6%94%b6%e8%8e%b7><i class="fa fa-link" aria-hidden=true></i></a></h2><h3 id=trylock和gosched的组合用法><code>TryLock</code>和<code>Gosched</code>的组合用法
<a class=heading-link href=#trylock%e5%92%8cgosched%e7%9a%84%e7%bb%84%e5%90%88%e7%94%a8%e6%b3%95><i class="fa fa-link" aria-hidden=true></i></a></h3><p>检测到并发时，让其他goroutine获得调度，如果不是在这学到我可能自己怎么也想不到这样写。。。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=display:flex><span><span style=color:#000;font-weight:700>for</span> {
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>if</span> la.updateLock.<span style=color:#900;font-weight:700>TryLock</span>() {
</span></span><span style=display:flex><span>    old = bg.<span style=color:#900;font-weight:700>ResetBucketTo</span>(old, bucketStart)
</span></span><span style=display:flex><span>    la.updateLock.<span style=color:#900;font-weight:700>Unlock</span>()
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>return</span> old, <span style=color:#000;font-weight:700>nil</span>
</span></span><span style=display:flex><span>    } <span style=color:#000;font-weight:700>else</span> {
</span></span><span style=display:flex><span>        runtime.<span style=color:#900;font-weight:700>Gosched</span>()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>if</span> ohter {
</span></span><span style=display:flex><span>        <span style=color:#000;font-weight:700>break</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#998;font-style:italic>/////////
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic>// tryLock的定义
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span><span style=color:#000;font-weight:700>const</span> mutexLocked = <span style=color:#099>1</span> <span style=color:#000;font-weight:700>&lt;&lt;</span> <span style=color:#000;font-weight:700>iota</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#998;font-style:italic>// The mutex which supports try-locking.
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span><span style=color:#000;font-weight:700>type</span> mutex <span style=color:#000;font-weight:700>struct</span> {
</span></span><span style=display:flex><span>	sync.Mutex
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#998;font-style:italic>// TryLock acquires the lock only if it is free at the time of invocation.
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span><span style=color:#000;font-weight:700>func</span> (tl <span style=color:#000;font-weight:700>*</span>mutex) <span style=color:#900;font-weight:700>TryLock</span>() <span style=color:#458;font-weight:700>bool</span> {
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>return</span> atomic.<span style=color:#900;font-weight:700>CompareAndSwapInt32</span>((<span style=color:#000;font-weight:700>*</span><span style=color:#458;font-weight:700>int32</span>)(unsafe.<span style=color:#900;font-weight:700>Pointer</span>(<span style=color:#000;font-weight:700>&amp;</span>tl.Mutex)), <span style=color:#099>0</span>, mutexLocked)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=unsafepointer用法>unsafe.Pointer用法
<a class=heading-link href=#unsafepointer%e7%94%a8%e6%b3%95><i class="fa fa-link" aria-hidden=true></i></a></h3><p>在初始化环形数组的时候用到了<code>*util.SliceHeader</code></p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=display:flex><span>sliHeader <span style=color:#000;font-weight:700>:=</span> (<span style=color:#000;font-weight:700>*</span>util.SliceHeader)(unsafe.<span style=color:#900;font-weight:700>Pointer</span>(<span style=color:#000;font-weight:700>&amp;</span>ret.data))
</span></span><span style=display:flex><span>ret.base = unsafe.<span style=color:#900;font-weight:700>Pointer</span>((<span style=color:#000;font-weight:700>**</span>BucketWrap)(unsafe.<span style=color:#900;font-weight:700>Pointer</span>(sliHeader.Data)))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#998;font-style:italic>/////
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic>// SliceHeader 的定义
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic>// SliceHeader is a safe version of SliceHeader used within this project.
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span><span style=color:#000;font-weight:700>type</span> SliceHeader <span style=color:#000;font-weight:700>struct</span> {
</span></span><span style=display:flex><span>	Data unsafe.Pointer
</span></span><span style=display:flex><span>	Len  <span style=color:#458;font-weight:700>int</span>
</span></span><span style=display:flex><span>	Cap  <span style=color:#458;font-weight:700>int</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>不知道为什么不可以直接这样</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>ret.base = unsafe.Pointer(sliHeader.Data))
</span></span></code></pre></div><p>这个问题在repo进行了提问。。 请戳 <a href=https://github.com/alibaba/sentinel-golang/issues/546>https://github.com/alibaba/sentinel-golang/issues/546</a><br>以及对于第二行<code>(**BucketWrap)(unsafe.Pointer)</code>的转换也不是很懂</p><h2 id=总结>总结
<a class=heading-link href=#%e6%80%bb%e7%bb%93><i class="fa fa-link" aria-hidden=true></i></a></h2><p>通过环形数组实现滑动窗口，记住滑动窗口最终要的两个属性，长度和分桶数，它们决定了统计周期、粒度、滑动步长。以及最重要的两个方法：<code>AddCount</code>和<code>GetSum</code>。代码中关于<code>unsafe.Pointer</code>还有一些没彻底读懂的地方，下次继续学习吧！</p></div><footer></footer></article></section></div><footer class=footer><section class=container>©
2024
bincat
·
Powered by <a href=https://gohugo.io/>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/>Coder</a>.</section></footer></main><script src=/js/coder.min.9cf2dbf9b6989ef8eae941ffb4231c26d1dc026bca38f1d19fdba50177d8a9ac.js integrity="sha256-nPLb+baYnvjq6UH/tCMcJtHcAmvKOPHRn9ulAXfYqaw="></script></body></html>