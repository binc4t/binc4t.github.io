<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on where dream begins!</title><link>https://binc4t.github.io/posts/</link><description>Recent content in Posts on where dream begins!</description><generator>Hugo</generator><language>en</language><lastBuildDate>Fri, 07 Jun 2024 21:59:26 +0800</lastBuildDate><atom:link href="https://binc4t.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>NTP 协议</title><link>https://binc4t.github.io/posts/ntp/</link><pubDate>Fri, 07 Jun 2024 21:59:26 +0800</pubDate><guid>https://binc4t.github.io/posts/ntp/</guid><description>Port Description 123 (UDP) NTP (Network Time Protocol). 什么是NTP协议 NTP(Network Time Protocol) 网络时间协议，运行在123端口上， 用于时间同步
NTP 通过分级的方式来组织所有节点，从0到15，共15级，0级是最准确的时间设备，从0级同步时间的设备是1级设备，依次类推
网络上的设备是一个既做服务器又做客户端的模型，在从其他设备获取时间后，其他设备同样可以从你这里获取时间
具体linux设备上，可以启动ntpd，ntpd通过ntp协议来同步时钟
NTP协议的原理 NTP原理简单理解起来就是， 假设A想从B初同步时间，那么需要向B发起请求，B把自己的时间发给A，但是因为网络延迟的原因，B的消息传达给A要过一个单程延迟，因此A需要知道单程延迟是多少
从A和B的两次通信中，其实就可以估算出网络延迟
借用此处的图片来说明
其中
t1 是客户端发送数据时, 客户端的时间 t2 是服务端收到数据时, 服务器的时间 t3 是服务端发送数据时, 服务器的时间 t4 是客户端收到数据时, 客户端的时间
利用这四个时间就可以估算出延迟offset
client就可以用t3 + offset 来校准时间</description></item><item><title>DHCP 协议</title><link>https://binc4t.github.io/posts/dhcp/</link><pubDate>Sat, 01 Jun 2024 23:07:52 +0800</pubDate><guid>https://binc4t.github.io/posts/dhcp/</guid><description>新开了一个支线任务：探索Linux Common Port
本次任务： 端口 描述 67 (UDP) Used by the DHCP server (Dynamic Host Configuration Protocol). 68 (UDP) Used by a DHCP client. 67和68两个端口用于DHCP协议，分别是服务端和客户端
DHCP是应用层协议，传输层协议使用的是UDP
什么是DHCP DHCP(Dynamic Host Configurration Protocol)协议，动态路由配置协议，用于动态分配IP
你走进咖啡厅，用手机连接咖啡厅的公共wifi，此时你的手机将需要被动态分配一个IP，才能用语网络通信，那么这个动态IP由谁负责给你，又是通过什么方式给你呢？
一般负责动态IP分配的是路由器，而分配动态IP所遵循的协议就是DHCP，下面就是你从连接咖啡厅wifi到分配ip的过程：
当你的手机连接到咖啡厅的公共WiFi网络时,它会向WiFi路由器发送请求,希望获得一个IP地址以接入互联网。 路由器上运行着DHCP(动态主机配置协议)服务,它负责动态分配IP地址。DHCP服务器会从可用的内网IP地址池中选择一个空闲的IP地址,并将其分配给你的手机。 DHCP服务器把分配的IP地址、子网掩码、默认网关等信息以DHCP协议的方式发送回你的手机。 你的手机收到DHCP服务器的响应后,就可以使用这个动态分配的内网IP地址来接入互联网了。 上面获取动态IP的过程就是DHCP
DHCP 的具体过程 简单来说，四次通信即可完成。
(Discover) client -&amp;gt; servers 广播 Hi，当前广播区域内谁可以给我分配一个动态IP？
(Offer) server A -&amp;gt; client 单播 我可以给你一个动态IP地址！你的地址是xxx，子网掩码是xxx，dns服务器是xxx，以及其他有用的信息
(Request) client -&amp;gt; servers 广播 我觉得server A 很不错，我要选定server A提供给我的动态IP地址
(ACK) server A -&amp;gt; client 单播 这里是你的动态IP地址！你的地址是xxx，子网掩码是xxx，dns服务器是xxx，以及其他有用的信息</description></item><item><title>使用karabiner实现vim的中英文输入法丝滑切换</title><link>https://binc4t.github.io/posts/vim-switch-cn-en/</link><pubDate>Sat, 24 Feb 2024 17:56:47 +0800</pubDate><guid>https://binc4t.github.io/posts/vim-switch-cn-en/</guid><description>#vim
背景 vim从编辑模式退出到普通模式下的时候，需要手动切换到英文输入法，其他编辑器的vim模式同样存在此问题，我想在vim退出编辑模式时自动切换为英文输入法
实现这个功能有两个思路：
vim插件 修改键盘映射 vim插件的办法这里不做介绍，因为vim插件无法在其他编辑器的vim模式下使用 这里采用karabiner修改键位映射来实现，karabiner是一个很方便的键位修改软件，我一直在使用，解决此问题的思路是：修改ESC的键盘映射，实现在按下ESC的同时，修改输入法为英文
如何实现 karabiner 允许用户通过json的形式自定义键位映射，点击下面红框部分，可以通过一段json来自定义键位的行为 下面是实现该功能的json配置，其含义是： 在当前输入法不是英文的前提下，按下ESC时，会先按下ESC，同时把输入法切换为英文
这段json的语法是karabiner的json配置语法，可以在karabiner官网找到详细的karabiner json语法介绍，语法还是比较直观的
{ &amp;#34;description&amp;#34;: &amp;#34;ESC: ESC and language to en&amp;#34;, &amp;#34;manipulators&amp;#34;: [ { &amp;#34;type&amp;#34;: &amp;#34;basic&amp;#34;, &amp;#34;conditions&amp;#34;: [ { &amp;#34;type&amp;#34;: &amp;#34;input_source_unless&amp;#34;, &amp;#34;input_sources&amp;#34;: [ { &amp;#34;input_source_id&amp;#34;: &amp;#34;^com\\.apple\\.keylayout\\.ABC$&amp;#34;, &amp;#34;language&amp;#34;: &amp;#34;^en$&amp;#34; } ] } ], &amp;#34;from&amp;#34;: { &amp;#34;key_code&amp;#34;: &amp;#34;escape&amp;#34; }, &amp;#34;to&amp;#34;: [ { &amp;#34;key_code&amp;#34;: &amp;#34;escape&amp;#34; }, { &amp;#34;select_input_source&amp;#34;: { &amp;#34;input_source_id&amp;#34;: &amp;#34;^com\\.apple\\.keylayout\\.ABC$&amp;#34;, &amp;#34;language&amp;#34;: &amp;#34;^en$&amp;#34; } } ] } ] } 在karabiner启用这段json配置之后，就可以体验丝滑的vim中英文切换了！</description></item><item><title>dnsmasq 使用备忘</title><link>https://binc4t.github.io/posts/dnsmasq/</link><pubDate>Fri, 12 Jan 2024 23:04:41 +0800</pubDate><guid>https://binc4t.github.io/posts/dnsmasq/</guid><description>最近在给手机测试时，想要把手机上对特定域名的请求劫持到Mac上来，就需要用到dnsmasq，把Mac变成一个dns服务器，然后手机的dns服务器地址修改到mac上来。下面做一个配置备忘
参考：https://blog.niekun.net/archives/1869.html
省略安装步骤，debian用 apt install，mac用 brew install 即可，下面进行配置
dnsmasq会按照一定的顺序去进行域名解析
首先是系统以及自定义的hosts文件： /etc/hosts /etc/hosts.dnsmasq 然后是上游dns server，定义在：resolv.dnsmasq.conf 默认dns server记录在/etc/resolv.conf文件中，既然我们要使用dnsmasq来做dns服务器，那么就应该让dnsmasq能够查询系统原本的dns sever，等于是用dnsmasq做了一个中继
sudo cp /etc/resolv.conf /etc/resolv.dnsmasq.conf 然后在/etc/resolv.conf文件中，将内容改为
nameserver 127.0.0.1 这样就把本机的dns server指向了 127.0.0.1，这时候机器的dns请求就会发往127.0.0.1的53端口，dns默认监听端口，也是dnsmasq的监听端口
这里注意，在mac上需要在设置-网络-DNS中修改DNS服务器·
然后再在 /etc/dnsmasq.conf 文件中输入配置
# 监听地址： # 如果只写 127.0.0.1 则只处理本机的 DNS 解析，不写这句默认监听所有网口 # listen-address=127.0.0.1,192.168.8.132 # 指定自定义 hosts 文件： addn-hosts=/etc/hosts.dnsmasq # 指定上游 DNS 服务列表的配置文件 resolv-file=/etc/resolv.dnsmasq.conf # 按照 DNS 列表一个个查询，不重新排列 DNS server 的顺序 strict-order # 表示对下面设置的所有 server 发起查询请求，选择响应最快的服务器的结果 all-servers 这样配置过程就完成了！
注意！如果在mac下用homebrew安装的，那么配置文件在/opt/homebrew/etc/dnsmasq.d/dnsmasq.conf
此时本机的dns请求的查询路径就会是
/etc/hosts -&amp;gt; dnsmasq 然后dnsmasq又会依次检索</description></item><item><title>2023 阅读记录</title><link>https://binc4t.github.io/posts/reading_2023/</link><pubDate>Sun, 31 Dec 2023 10:06:39 +0800</pubDate><guid>https://binc4t.github.io/posts/reading_2023/</guid><description>2023 读书记录 在读 Unix环境高级编程 APUE 经典名著&amp;hellip; 15章 进程间通信 1，2，3
自己动手实现Lua 23% 哪个程序员能拒绝自己实现一台虚拟机呢
编写可读代码的艺术 30% 短小精悍
在刷 MIT 6.824 分布式系统课程 课件 视频
1章 Introduction 2章 RPC and Threads 3章 GFS 读完 Head First JavaScript程序设计 娓娓道来，培养兴趣，入门好书
那些想红的年轻人 介绍自媒体商业模式和自媒体从业者心路历程的好书，作者很真诚，值得一看</description></item><item><title>Go by Example</title><link>https://binc4t.github.io/posts/go-by-example/</link><pubDate>Sun, 10 Dec 2023 13:36:32 +0800</pubDate><guid>https://binc4t.github.io/posts/go-by-example/</guid><description>重归基础 通过例子来学习Go
英文版本：https://gobyexample.com/
中文版本：https://gobyexample-cn.github.io/
笔记 迭代和递归 重新感受一下斐波那契数列的递归和迭代算法性能差距
// feb.go func FebRecursive(n int) int { if n == 0 { return 0 } if n == 1 { return 1 } return FebRecursive(n-1) + FebRecursive(n-2) } func FebIterative(n int) int { if n == 0 { return 0 } a, b := 0, 1 for i := 1; i &amp;lt; n; i++ { b = a + b a = b - a } return b } // feb_test.</description></item><item><title>学习 sentinel-golang 的滑动窗口实现</title><link>https://binc4t.github.io/posts/sentinel-golang_slidingwindow/</link><pubDate>Sun, 03 Sep 2023 10:06:39 +0800</pubDate><guid>https://binc4t.github.io/posts/sentinel-golang_slidingwindow/</guid><description>前言 最近工作中需要用到限频的功能，限制同IP在一定时间内的访问量，又因为想做成统计周期可配置，所以令牌桶不太适用，需要用滑动窗口来实现，发现了一个专门做流量访问控制的阿里的开源项目sentinel，奈何自己太菜了，直接引用了其中的滑动窗口的实现，不过还是学习了人家的写法并记录在这里
滑动窗口的基本属性 滑动窗口有两个最基本的属性，长度以及分桶数；长度决定了这个窗口有多长，也就是统计周期；分桶数决定了这个窗口的统计颗粒度。
那么滑动窗口该怎么实现呢？
滑动窗口不断向前滚动，采用新的数据，抛弃旧的数据，就很容易让人联想到环形数组。都是不断淘汰旧的数据，每次关心的只有这个环的大小，更新的和更旧的数据都不关心。
一起看一下sentinel-golang中的滑动窗口实现吧
sentinel-golang的滑动窗口实现 定义一个桶 首先定义一个桶，最简单的桶就是一个counter，下面的MetricBucket就定义了一个桶，这里的counter是二维统计，可以将Pass, Reject, Total等维度分别统计，下面的minRT和maxConcurrency可以暂时不用关心， 可以看出一个桶本质上就是一个counter
type MetricBucket struct { // Value of statistic counter [base.MetricEventTotal]int64 minRt int64 maxConcurrency int32 } 通过面的函数可以对counter值做加法
func (mb *MetricBucket) addCount(event base.MetricEvent, count int64) { atomic.AddInt64(&amp;amp;mb.counter[event], count) } 上面的桶放之四海皆可，但是如果想成为个滑动窗口用桶，只有counter是不够的，因为滑动窗口中的每一个桶还有时间的概念，BucketWrap是对桶的封装，添加了开始时间BucketStart，Value中存放的是一个*MetricBucket
type BucketWrap struct { // BucketStart represents start timestamp of this statistic bucket wrapper. BucketStart uint64 // Value represents the actual data structure of the metrics (e.g. MetricBucket). Value atomic.</description></item><item><title>Tendermint笔记</title><link>https://binc4t.github.io/posts/tendermint/</link><pubDate>Fri, 15 Apr 2022 00:41:31 +0800</pubDate><guid>https://binc4t.github.io/posts/tendermint/</guid><description>参考资料 什么是Tendermint
什么是Tendermint Tendermint 是一种区块链的构建工具，或者区块链的开发框架，能够帮助开发者快速构建一条区块链。它主要包含两个部分：Tendermint Core 以及 ABCI(Application Blockchain Interface)，前者通过BFT实现了一种共识协议以及P2P网络通信，后者则定义了搭建在 Tendermint Core 之上的应用层接口。
Tendermint Core 将区块链共识协议层和对等网络通信层实现，使得开发者能够不用过分关心复杂的底层实现，而专注于应用层开发。借用Dan Boneh提到的区块链网络分层模型，我认为Tendermint Core实现了下两层的内容，如下图所示。</description></item><item><title>pbft笔记</title><link>https://binc4t.github.io/posts/pbft/</link><pubDate>Tue, 12 Apr 2022 23:36:57 +0800</pubDate><guid>https://binc4t.github.io/posts/pbft/</guid><description>参考资料 PBFT 论文
FISCO-BCOS的PBFT介绍
Liskov对PBFT的讲解
What is Tendermint
论文笔记 一些记录 3f+1 is the minimum number of replicas that allow an asynchronous system to provide the safety and liveness properties when up to f replicas are faulty
在一个由3f+1个节点构成的系统中，最多有f个恶意节点，才能保证系统的safty和liveness
This many replicas are needed because it must be possible to proceed after communicating with n-f replicas, since f replicas might be faulty and not responding. However, it is possible that the f replicas that did not respond are not faulty and, therefore, f of those that responded might be faulty.</description></item><item><title>刷题记录</title><link>https://binc4t.github.io/posts/rp-diary/</link><pubDate>Sat, 02 Apr 2022 00:15:03 +0800</pubDate><guid>https://binc4t.github.io/posts/rp-diary/</guid><description>刷题统计 4.1 二分搜索
704. Binary Search
278. First Bad Version
35. Search Insert Position
4.2 双指针&amp;amp;矩阵搜索
#3 无重复字符的最长子串
#19 删除链表的倒数第 N 个结点
#876 链表的中间结点 #557 反转字符串中的单词 III #240 搜索二维矩阵 II
#344 反转字符串 #11 盛最多水的容器
#167 两数之和 II - 输入有序数组
#283 移动零 #189 轮转数组
#977 有序数组的平方
4.3 滑动窗口
#567 字符串的排列
#3 无重复字符的最长子串
#567 字符串的排列
栈和队列 #232 用栈实现队列
#20 有效的括号
链表
#206 反转链表
4.4 二叉树
#236 二叉树的最近公共祖先
#117 填充每个节点的下一个右侧节点指针 II
#116 填充每个节点的下一个右侧节点指针</description></item></channel></rss>