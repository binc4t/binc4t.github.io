<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="bincat"><meta name=description content="重归基础 通过例子来学习Go
英文版本：https://gobyexample.com/
中文版本：https://gobyexample-cn.github.io/
笔记 迭代和递归 重新感受一下斐波那契数列的递归和迭代算法性能差距
// feb.go func FebRecursive(n int) int { if n == 0 { return 0 } if n == 1 { return 1 } return FebRecursive(n-1) + FebRecursive(n-2) } func FebIterative(n int) int { if n == 0 { return 0 } a, b := 0, 1 for i := 1; i < n; i++ { b = a + b a = b - a } return b } // feb_test."><meta name=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content="Go by Example"><meta name=twitter:description content="重归基础 通过例子来学习Go
英文版本：https://gobyexample.com/
中文版本：https://gobyexample-cn.github.io/
笔记 迭代和递归 重新感受一下斐波那契数列的递归和迭代算法性能差距
// feb.go func FebRecursive(n int) int { if n == 0 { return 0 } if n == 1 { return 1 } return FebRecursive(n-1) + FebRecursive(n-2) } func FebIterative(n int) int { if n == 0 { return 0 } a, b := 0, 1 for i := 1; i < n; i++ { b = a + b a = b - a } return b } // feb_test."><meta property="og:url" content="https://binc4t.github.io/posts/go-by-example/"><meta property="og:site_name" content="where dream begins!"><meta property="og:title" content="Go by Example"><meta property="og:description" content="重归基础 通过例子来学习Go
英文版本：https://gobyexample.com/
中文版本：https://gobyexample-cn.github.io/
笔记 迭代和递归 重新感受一下斐波那契数列的递归和迭代算法性能差距
// feb.go func FebRecursive(n int) int { if n == 0 { return 0 } if n == 1 { return 1 } return FebRecursive(n-1) + FebRecursive(n-2) } func FebIterative(n int) int { if n == 0 { return 0 } a, b := 0, 1 for i := 1; i < n; i++ { b = a + b a = b - a } return b } // feb_test."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-12-10T13:36:32+08:00"><meta property="article:modified_time" content="2023-12-10T13:36:32+08:00"><title>Go by Example · where dream begins!
</title><link rel=canonical href=https://binc4t.github.io/posts/go-by-example/><link rel=preload href="/fonts/forkawesome-webfont.woff2?v=1.2.0" as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.d9fddbffe6f27e69985dc5fe0471cdb0e57fbf4775714bc3d847accb08f4a1f6.css integrity="sha256-2f3b/+byfmmYXcX+BHHNsOV/v0d1cUvD2Eesywj0ofY=" crossorigin=anonymous media=screen><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><meta name=generator content="Hugo 0.126.2"></head><body class="preload-transitions colorscheme-light"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=/>where dream begins!
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/posts/>Blog</a></li><li class=navigation-item><a class=navigation-link href=/reading>Reading</a></li><li class=navigation-item><a class=navigation-link href=/about>About</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://binc4t.github.io/posts/go-by-example/>Go by Example</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa fa-calendar" aria-hidden=true></i>
<time datetime=2023-12-10T13:36:32+08:00>December 10, 2023
</time></span><span class=reading-time><i class="fa fa-clock-o" aria-hidden=true></i>
One-minute read</span></div></div></header><div><h1 id=重归基础>重归基础
<a class=heading-link href=#%e9%87%8d%e5%bd%92%e5%9f%ba%e7%a1%80><i class="fa fa-link" aria-hidden=true></i></a></h1><p>通过例子来学习Go<br>英文版本：https://gobyexample.com/<br>中文版本：https://gobyexample-cn.github.io/</p><h1 id=笔记>笔记
<a class=heading-link href=#%e7%ac%94%e8%ae%b0><i class="fa fa-link" aria-hidden=true></i></a></h1><h2 id=迭代和递归>迭代和递归
<a class=heading-link href=#%e8%bf%ad%e4%bb%a3%e5%92%8c%e9%80%92%e5%bd%92><i class="fa fa-link" aria-hidden=true></i></a></h2><p>重新感受一下斐波那契数列的递归和迭代算法性能差距</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#998;font-style:italic>// feb.go
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>FebRecursive</span>(n <span style=color:#458;font-weight:700>int</span>) <span style=color:#458;font-weight:700>int</span> {
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>if</span> n <span style=color:#000;font-weight:700>==</span> <span style=color:#099>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#000;font-weight:700>return</span> <span style=color:#099>0</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>if</span> n <span style=color:#000;font-weight:700>==</span> <span style=color:#099>1</span> {
</span></span><span style=display:flex><span>		<span style=color:#000;font-weight:700>return</span> <span style=color:#099>1</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>return</span> <span style=color:#900;font-weight:700>FebRecursive</span>(n<span style=color:#000;font-weight:700>-</span><span style=color:#099>1</span>) <span style=color:#000;font-weight:700>+</span> <span style=color:#900;font-weight:700>FebRecursive</span>(n<span style=color:#000;font-weight:700>-</span><span style=color:#099>2</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>FebIterative</span>(n <span style=color:#458;font-weight:700>int</span>) <span style=color:#458;font-weight:700>int</span> {
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>if</span> n <span style=color:#000;font-weight:700>==</span> <span style=color:#099>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#000;font-weight:700>return</span> <span style=color:#099>0</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	a, b <span style=color:#000;font-weight:700>:=</span> <span style=color:#099>0</span>, <span style=color:#099>1</span>
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>for</span> i <span style=color:#000;font-weight:700>:=</span> <span style=color:#099>1</span>; i &lt; n; i<span style=color:#000;font-weight:700>++</span> {
</span></span><span style=display:flex><span>		b = a <span style=color:#000;font-weight:700>+</span> b
</span></span><span style=display:flex><span>		a = b <span style=color:#000;font-weight:700>-</span> a
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>return</span> b
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#998;font-style:italic>// feb_test.go
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>Benchmark_FebIterative</span>(b <span style=color:#000;font-weight:700>*</span>testing.B) {
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>for</span> i <span style=color:#000;font-weight:700>:=</span> <span style=color:#099>0</span>; i &lt; b.N; i<span style=color:#000;font-weight:700>++</span> {
</span></span><span style=display:flex><span>		<span style=color:#900;font-weight:700>FebIterative</span>(<span style=color:#099>30</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>Benchmark_FebRecursive</span>(b <span style=color:#000;font-weight:700>*</span>testing.B) {
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>for</span> i <span style=color:#000;font-weight:700>:=</span> <span style=color:#099>0</span>; i &lt; b.N; i<span style=color:#000;font-weight:700>++</span> {
</span></span><span style=display:flex><span>		<span style=color:#900;font-weight:700>FebRecursive</span>(<span style=color:#099>30</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=字符串和rune>字符串和rune
<a class=heading-link href=#%e5%ad%97%e7%ac%a6%e4%b8%b2%e5%92%8crune><i class="fa fa-link" aria-hidden=true></i></a></h2><p>调用 len 得到字节长度
for range 是按照rune来遍历</p><blockquote><p>下面内容引用自 <a href=https://liyucang-git.github.io/2019/06/17/%E5%BD%BB%E5%BA%95%E5%BC%84%E6%87%82Unicode%E7%BC%96%E7%A0%81/>https://liyucang-git.github.io/2019/06/17/%E5%BD%BB%E5%BA%95%E5%BC%84%E6%87%82Unicode%E7%BC%96%E7%A0%81/</a></p></blockquote><p>它从 0 开始，为每个符号指定一个编号，这叫做”码点”（code point）。比如，码点 0 的符号就是 null（表示所有二进制位都是 0）。</p><p>U+0000 = null
上式中，U+表示紧跟在后面的十六进制数是 Unicode 的码点。</p><p>这么多符号，Unicode 不是一次性定义的，而是分区定义。每个区可以存放 65536 个（2^16）字符，称为一个平面（plane）。目前，一共有 17 个平面，也就是说，整个 Unicode 字符集的大小现在是 2^21。</p><p>最前面的 65536 个字符位，称为基本平面（缩写 BMP），它的码点范围是从 0 一直到 2^16-1，写成 16 进制就是从 U+0000 到 U+FFFF。所有最常见的字符都放在这个平面，这是 Unicode 最先定义和公布的一个平面。</p><p>剩下的字符都放在辅助平面（缩写 SMP），码点范围从 U+010000 一直到 U+10FFFF。</p><p>Go 源码文件默认采用 Unicode 字符集，Unicode 码点和内存中字节序列的变换实现使用了 UTF-8</p><h2 id=范型>范型
<a class=heading-link href=#%e8%8c%83%e5%9e%8b><i class="fa fa-link" aria-hidden=true></i></a></h2><p><a href=https://segmentfault.com/a/1190000041634906>https://segmentfault.com/a/1190000041634906</a></p><h2 id=池>池
<a class=heading-link href=#%e6%b1%a0><i class="fa fa-link" aria-hidden=true></i></a></h2><p>思路：协程池和多路I/O复用</p><p>实现参考: <a href=https://github.com/bytedance/gopkg/tree/develop/util/gopool>https://github.com/bytedance/gopkg/tree/develop/util/gopool</a></p><p>高并发场景下，使用协程池来减少协程创建的开销，减少内存分配的频率</p><p>模仿(照抄)上面的gopool实现了一个协程池：https://github.com/binc4t/wpool</p><p>主要组件：
task pool<br>worker pool</p><ol><li>从task pool取出task，赋值一个执行func, 放入队列，这里用单向链表实现队列</li><li>查看task队列的task数量，超过阈值则从worker pool中取得一个worker</li><li>worker main 循环，不断获取task并执行，如果没有task，则回收这个worker，放入worker pool</li></ol></div><footer></footer></article></section></div><footer class=footer><section class=container>©
2024
bincat
·
Powered by <a href=https://gohugo.io/>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/>Coder</a>.</section></footer></main><script src=/js/coder.min.9cf2dbf9b6989ef8eae941ffb4231c26d1dc026bca38f1d19fdba50177d8a9ac.js integrity="sha256-nPLb+baYnvjq6UH/tCMcJtHcAmvKOPHRn9ulAXfYqaw="></script></body></html>